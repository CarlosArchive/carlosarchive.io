---
title: "Docker and Containerisation"
summary: 
date: 2026-02-10
series: ["PaperMod"]
weight: 1
aliases: ["/Docker-1"]
tags: ["Docker"]
author: ["Carlos A"]
---
Previously I have written about [Kubernetes](https://carlosarchive.github.io/carlosarchive.io/posts/20251218-kubernetes/). I briefly explained that it uses something called containers and what problems it intended to solve.

This article will go a bit more in depth into containers and Docker, which has become the most popular platform for managing containers and become somewhat synonymous with containers and containerisation.

## What is a container?

A container is an isolated process that contains everything required for your application.
Containers have their own filesystems and are isolated from each other, but share the same host OS kernel. This is what separates them from VMs, which have their own kernel and simulate bare metal machines. As they are faster to build and deploy compared to VMs, containers have become popular in modern software development practices.

## Images

A Docker image is a standalone software package which contains everything required to run a container. Images consist of layers, each of which contains a set of changes e.g. adding, modifying or deleting files. An example image could consist of the following layers: a base layer which contains a minimal operating system in which the application can run, another layer which installs an appropriate runtime like Python and then a final layer which builds the application code.

## Dockerfiles

Images are built by running 'docker build' commands in a directory that contains a Dockerfile. 
A Dockerfile is a document that is used to create an image. Dockerfiles contain instructions of commands to run in order to build an application. Here's a basic example:

~~~
FROM python:3.13
WORKDIR /usr/local/app

# Install the application dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt

# Copy in the source code
COPY src ./src
EXPOSE 8080

# Setup an app user so the container doesn't run as the root user
RUN useradd app
USER app

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]
~~~

Some of the commands are fairly self-explanatory, but to highlight a few:

FROM indicates the starting image for your docker image to start building on/extending.

WORKDIR specifies the directory from within the image where commands are run and files are copied.

EXPOSE sets a port on the image that needs to be exposed to listen on.

ENV sets an environment variable in the image that the container will use.

ARG denotes build-time variables that are passed in via the command line, but not kept in the image like ENV.

CMD defines the default command a container from this image will run.

## Storing images

When images are built, images are stored on your computer. If you want to share them or use them elsewhere, you can push them to a docker registry. These are public or private locations to which you can store docker images for reuse. The default option is Dockerhub, but other cloud based offerings exist such as Google Artifact Registry, Amazon Elastic Container Registry and Azure Container Registry. You could also host your own container registry yourself, using something like Sonatype Nexus or JFrog Artifactory.
